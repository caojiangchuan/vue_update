<!DOCTYPE html>
<meta http-equiv="cache-control" content="no-cache">
<html>

<body>
    <div onclick="" style="font-size: 30px;">
        防抖测试
    </div>
</body>
<script>

    //原型属性，原型方法：

    //四种排序方法
    //第一种：冒泡排序
    {
        let list = [1, 4, 2, 33, 32, 14, 0, 90, 8, 3]

        for (let i = 0; i < list.length; i++) {
            for (let j = 0; j < list.length; j++) {
                if (list[j] > list[j + 1]) {
                    var trmp = list[j]
                    list[j] = list[j + 1]
                    list[j + 1] = trmp
                }
            }
        }
        console.log(list)
        //思想：比较相邻的前后两个数据，如果前面的大于后面的，就交换两个数据位置，直到遍历完数组，排序完成。

    }
    //第二种，选择排序
    {
        let list = [1, 4, 2, 33, 32, 14, 0, 90, 8, 3]
        let trmp //记录调换的索引
        for (let i = 0; i < list.length; i++) {
            // trmp = list[i]
            trmp = i
            for (let k = i + 1; k < list.length; k++) {
                if (list[trmp] > list[k]) {
                    trmp = k
                }

            }

            let all = list[i]
            list[i] = list[trmp]
            list[trmp] = all

        }
        console.log(list)
        //思想：第一次遍历数组找出最小的值与第一个元素交换，第二次遍历N-1个数据，找出最小的值与第二个元素交换，直到排序完成。
    }

    //第三种 快速排序

    {

        let quickSort = function (arr) {

            if (arr.length <= 1) { return arr; }

            let pivotIndex = Math.floor(arr.length / 2);

            let pivot = arr.splice(pivotIndex, 1)[0];//pivot是被删除的元素，arr是splice处理过后的元素，两个加在一起就是原来的数组

            let left = [];

            let right = [];

            for (let i = 0; i < arr.length; i++) {

                if (arr[i] < pivot) {

                    left.push(arr[i]);

                } else {

                    right.push(arr[i]);

                }

            }

            return quickSort(left).concat([pivot]).concat(quickSort(right)); //递归合并数组

        };
        let arr = [1, 4, 2, 33, 32, 14, 0, 90, 8, 3]

        console.log(quickSort(arr));

    }//思想：先从数组找设置一个基准数（任意，一般取中间）；将比基准数打的全放在它的右边，小的放在左边；在对左右两个区间重复第1、2步，直到区间各剩一个数。

    //第四种，插入排序

    {
        function insertSort(arr) {
            var len = arr.length;
            for (var i = 1; i < len; i++) {
                var key = arr[i];
                var j = i - 1;
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = key;
            }
            return arr;
        }
        let arr = [1, 4, 2, 33, 32, 14, 0, 90, 8, 3]

        console.log(insertSort(arr));
    }
    //思想：从第一个元素开始，该元素可以认为已经被排序；
    // 取出下一个元素，在已经排序的元素序列中从后向前扫描；
    // 如果该元素（已排序）大于新元素，将该元素移到下一位置；
    // 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
    // 将新元素插入到该位置后；

    {
        var list = [
            {
                price: 10,
                star: 1000,
                mount: 2
            }, {
                price: 10,
                star: 100,
                mount: 12
            }, {
                price: 90,
                star: 10,
                mount: 2
            }, {
                price: 109,
                star: 200,
                mount: 1020
            }
            , {
                price: 109,
                star: 200,
                mount: 100
            }, {
                price: 10,
                star: 10,
                mount: 120
            }, {
                price: 190,
                star: 120,
                mount: 102
            }, {
                price: 100,
                star: 100,
                mount: 12
            }]
        //    console.log(list)

        //    var newlist  = Object.assign([],list)
        var newlist = []

        for (var i = 0; i < list.length; i++) {
            newlist.push(list[i])
        }
        list.push({
            price: 100,
            star: 100,
            mount: 12
        })
        list.sort((a, b) => {
            if (a.price == b.price) {
                if (a.star == b.star) {
                    return a.mount - b.mount
                } else {


                    return a.star - b.star
                }
            } else {
                return (a.price - b.price)
            }
        })
    };

    console.log(newlist)

    //测试，冒泡
    {
        class Person {
            constructor(name, age) {
                this.name = name
                this.age = age

            }

            sayhello() {
                console.log('父类的hello方法' + this.name)
            }
        }
        // class 类中，可以使用extends 关键字，实现，子类继承父类
        // 语法 class 子类 extends 父类{}
        class American extends Person {
            constructor(name, age) {
                /**问题1： 为什么一定要在 constructor 中调用 super ？
                 * 因为，一个子类，通过extends 关键字继承了父类，那么，在这个子类的 constructor 构造函数中，必须优先调用一下 super()
                 * 问题2：super 是什么东西？
                 * super是一个函数，而且他是父类的 构造器，子类的super，其实就是父类中的 constructor 构造器的一个引用
                 * 问题3：为什么调用了 super()，之后name和age都变成了undefined？ 
                 * 实例化的时候 要把 参数 name age 传递进去 给 constructor再给super
                 */
                super(name, age)
            }
        }
        const a1 = new American('Jack', '20')
        console.log(a1)
        a1.sayhello()



    }

    {
        function father(name, age) {
            this.age = 'a'
            this.name = 'b'
        }

        function son() {

        }

        son.prototype = new father()
        var ss = new son()
        console.log(ss)
        //原型链继承
    }
    {
        async function bb(x) {
            let a = 10
            return x + a
        }
        console.log(bb(1))
    }
    {
        var a = 111
        function b() {
            console.log(a)
            function a() {

            }

            console.log(a)
            console.log(a)


        }
        b()
    }
{
    function A(){
    function B(){
        console.log('Hello Claaosure!');

       function S(){
        console.log('Hello Claosure!');

       }
       return S
    }
    return B;
}
var C = A();
C()();// Hello Closure!
}
</script>

</html>